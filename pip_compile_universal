#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import argparse
import os
import signal
import subprocess
import threading
import re
import sys
from pathlib import Path
from typing import List, Tuple


def parse_versions(versions):
	if not versions:
		raise argparse.ArgumentTypeError("Missing versions attribute")
	parsed_versions = []
	versions = versions.split(',')
	for version in versions:
		try:
			parsed_versions.append(tuple(int(num) for num in version.split('.')))
		except ValueError:
			raise argparse.ArgumentTypeError("Bad version format: %s" % version)
	return sorted(parsed_versions)


def get_output_and_args(compile_args):
	compile_args = compile_args[:]
	output_filename = 'requirements.txt'

	out_arg_idx = None
	try:
		out_arg_idx = compile_args.index('-o')
	except ValueError:
		pass
	if out_arg_idx:
		if out_arg_idx < len(compile_args) - 1:
			output_filename = compile_args[out_arg_idx + 1]
			compile_args[out_arg_idx + 1] = '-'
		else:
			compile_args.pop()
			out_arg_idx = None

	if out_arg_idx is None:
		compile_args.extend(['-o', '-'])

	return output_filename, compile_args


def check_proc_status(proc):
	if proc.returncode:
		raise subprocess.CalledProcessError(proc.returncode, ' '.join(proc.args))


def ensure_venv_exists(version_name, virtualenvs_dir):
	virtualenv_dir = virtualenvs_dir / f'py{version_name}'
	if not virtualenv_dir.exists():
		process_args = [f'python{version_name}', '-m', 'venv', str(virtualenv_dir)]
		proc = subprocess.Popen(process_args, preexec_fn=os.setpgrp)
		proc.wait()
		check_proc_status(proc)


class PipCompile(threading.Thread):
	def __init__(self, virtualenv_dir, compile_args):
		super().__init__()
		self.virtualenv_dir = virtualenv_dir
		self.compile_args = compile_args
		self.requirements = ''
		self.__stopping = False
		self.__proc = None

	@property
	def python_binary(self):
		return str(self.virtualenv_dir / 'bin' / 'python')

	@property
	def pip_binary(self):
		return str(self.virtualenv_dir / 'bin' / 'pip')

	@property
	def pip_compile_binary(self):
		return str(self.virtualenv_dir / 'bin' / 'pip-compile')

	def run(self):
		if self.__stopping:
			return
		self.__proc = subprocess.Popen([self.pip_binary, 'install', '--upgrade', 'pip-tools'], preexec_fn=os.setpgrp)
		self.__proc.communicate()
		if self.__stopping:
			return
		check_proc_status(self.__proc)
		self.__proc = None

		if self.__stopping:
			return
		self.__proc = subprocess.Popen([self.pip_compile_binary] + self.compile_args, stdout=subprocess.PIPE, preexec_fn=os.setpgrp)
		stdout, __ = self.__proc.communicate()
		if self.__stopping:
			return
		check_proc_status(self.__proc)
		if stdout:
			self.requirements = stdout.decode('utf-8')
		self.__proc = None

	def stop(self):
		self.__stopping = True
		proc = self.__proc
		if proc is not None:
			group = os.getpgid(proc.pid)
			proc.terminate()
			try:
				proc.wait(0.1)
			except:
				proc.kill()
			try:
				os.killpg(group, signal.SIGKILL)
			except Exception:
				pass

def split_requirements_and_comments(requirements_txt: str) -> List[Tuple[str, str]]:
	"""
	Returns pairs of requirement and comment
	"""
	lines = requirements_txt.splitlines()
	current_comment = ''
	current_requirement = ''
	requirements_list = []
	for line in lines:
		current_comment += '\n'
		if line.strip()[:1] == '#':
			current_comment += line
		else:
			if current_requirement:
				requirements_list.append((current_requirement, current_comment))
			current_requirement = ''
			current_comment = ''
			comment_pos = re.search(r'\s*#', line)
			if comment_pos is not None:
				comment_pos = comment_pos.start(0)
			if comment_pos is None:
				current_requirement = line
			else:
				current_comment = line[comment_pos:]
				current_requirement = line[:comment_pos]

	if current_requirement:
		requirements_list.append((current_requirement, current_comment))

	return requirements_list


def pip_compile(versions, compile_args, virtualenvs_dir):
	processes = []

	#output_filename, compile_args = get_output_and_args(compile_args)
	#for version in versions:
	#	version_name = ".".join(str(v) for v in version)
	#	virtualenv_dir = virtualenvs_dir / f'py{version_name}'
	#	ensure_venv_exists(version_name, virtualenvs_dir)
	#	compile_proc = PipCompile(virtualenv_dir, compile_args)
	#	compile_proc.start()
	#	processes.append(compile_proc)

	#def at_exit(*args):
	#	for proc in processes:
	#		proc.stop()

	#signal.signal(signal.SIGTERM, at_exit)
	#signal.signal(signal.SIGINT, at_exit)
	#signal.signal(signal.SIGHUP, at_exit)

	#requirements = []
	#for proc, version in zip(processes, versions):
	#	proc.join()
	#	version_name = ".".join(str(v) for v in version)
	#	requirements.append(proc.requirements)

	requirements = []
	for version in versions:
		version_name = ".".join(str(v) for v in version)
		with open(f'py{version_name}', 'r') as fp:
			requirements.append(fp.read())

	for version_requirements in requirements:
		version_requirements = split_requirements_and_comments(version_requirements)
		for req, comment in version_requirements:
			sys.stdout.write(req)
			sys.stdout.write(comment)


def main():
	parser = argparse.ArgumentParser(description="Compile requirements.in to single requirements.txt file with multiple python versions support")
	parser.add_argument('versions', type=parse_versions, help="Comma separated list of pythoon versions")
	parser.add_argument('--virtualenvs_dir', default=str(Path.home() / '.virtualenvs'), help="Where to create virtualenvs")
	parser.add_argument('pip_compile_args', nargs=argparse.REMAINDER, help="Arguments forwarded to pip-tools")
	args = parser.parse_args()
	pip_compile(args.versions, args.pip_compile_args, Path(args.virtualenvs_dir))


if __name__ == "__main__":
	main()
